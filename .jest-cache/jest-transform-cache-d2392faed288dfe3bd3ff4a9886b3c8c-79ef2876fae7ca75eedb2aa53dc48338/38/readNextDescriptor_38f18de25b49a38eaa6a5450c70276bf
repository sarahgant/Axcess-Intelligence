c290edd536782df5127ef65cc1b186ca
'use strict';

var bracketDict = /*#__PURE__*/function (bracketDict) {
  bracketDict["{"] = "}";
  bracketDict["["] = "]";
  return bracketDict;
}(bracketDict || {});
/**
 * Read the next key definition from user input
 *
 * Describe key per `{descriptor}` or `[descriptor]`.
 * Everything else will be interpreted as a single character as descriptor - e.g. `a`.
 * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.
 * A previously pressed key can be released per `{/descriptor}`.
 * Keeping the key pressed can be written as `{descriptor>}`.
 * When keeping the key pressed you can choose how long the key is pressed `{descriptor>3}`.
 * You can then release the key per `{descriptor>3/}` or keep it pressed and continue with the next key.
 */
function readNextDescriptor(text, context) {
  let pos = 0;
  const startBracket = text[pos] in bracketDict ? text[pos] : '';
  pos += startBracket.length;
  const isEscapedChar = new RegExp(`^\\${startBracket}{2}`).test(text);
  const type = isEscapedChar ? '' : startBracket;
  return {
    type,
    ...(type === '' ? readPrintableChar(text, pos, context) : readTag(text, pos, type, context))
  };
}
function readPrintableChar(text, pos, context) {
  const descriptor = text[pos];
  assertDescriptor(descriptor, text, pos, context);
  pos += descriptor.length;
  return {
    consumedLength: pos,
    descriptor,
    releasePrevious: false,
    releaseSelf: true,
    repeat: 1
  };
}
function readTag(text, pos, startBracket, context) {
  var _text_slice_match, _text_slice_match1;
  const releasePreviousModifier = text[pos] === '/' ? '/' : '';
  pos += releasePreviousModifier.length;
  const escapedDescriptor = startBracket === '{' && text[pos] === '\\';
  pos += Number(escapedDescriptor);
  const descriptor = escapedDescriptor ? text[pos] : (_text_slice_match = text.slice(pos).match(startBracket === '{' ? /^\w+|^[^}>/]/ : /^\w+/)) === null || _text_slice_match === undefined ? undefined : _text_slice_match[0];
  assertDescriptor(descriptor, text, pos, context);
  pos += descriptor.length;
  var _text_slice_match_;
  const repeatModifier = (_text_slice_match_ = (_text_slice_match1 = text.slice(pos).match(/^>\d+/)) === null || _text_slice_match1 === undefined ? undefined : _text_slice_match1[0]) !== null && _text_slice_match_ !== undefined ? _text_slice_match_ : '';
  pos += repeatModifier.length;
  const releaseSelfModifier = text[pos] === '/' || !repeatModifier && text[pos] === '>' ? text[pos] : '';
  pos += releaseSelfModifier.length;
  const expectedEndBracket = bracketDict[startBracket];
  const endBracket = text[pos] === expectedEndBracket ? expectedEndBracket : '';
  if (!endBracket) {
    throw new Error(getErrorMessage([!repeatModifier && 'repeat modifier', !releaseSelfModifier && 'release modifier', `"${expectedEndBracket}"`].filter(Boolean).join(' or '), text[pos], text, context));
  }
  pos += endBracket.length;
  return {
    consumedLength: pos,
    descriptor,
    releasePrevious: !!releasePreviousModifier,
    repeat: repeatModifier ? Math.max(Number(repeatModifier.substr(1)), 1) : 1,
    releaseSelf: hasReleaseSelf(releaseSelfModifier, repeatModifier)
  };
}
function assertDescriptor(descriptor, text, pos, context) {
  if (!descriptor) {
    throw new Error(getErrorMessage('key descriptor', text[pos], text, context));
  }
}
function hasReleaseSelf(releaseSelfModifier, repeatModifier) {
  if (releaseSelfModifier) {
    return releaseSelfModifier === '/';
  }
  if (repeatModifier) {
    return false;
  }
}
function getErrorMessage(expected, found, text, context) {
  return `Expected ${expected} but found "${found !== null && found !== undefined ? found : ''}" in "${text}"
    See ${context === 'pointer' ? `https://testing-library.com/docs/user-event/pointer#pressing-a-button-or-touching-the-screen` : `https://testing-library.com/docs/user-event/keyboard`}
    for more information about how userEvent parses your input.`;
}
exports.readNextDescriptor = readNextDescriptor;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJicmFja2V0RGljdCIsInJlYWROZXh0RGVzY3JpcHRvciIsInRleHQiLCJjb250ZXh0IiwicG9zIiwic3RhcnRCcmFja2V0IiwibGVuZ3RoIiwiaXNFc2NhcGVkQ2hhciIsIlJlZ0V4cCIsInRlc3QiLCJ0eXBlIiwicmVhZFByaW50YWJsZUNoYXIiLCJyZWFkVGFnIiwiZGVzY3JpcHRvciIsImFzc2VydERlc2NyaXB0b3IiLCJjb25zdW1lZExlbmd0aCIsInJlbGVhc2VQcmV2aW91cyIsInJlbGVhc2VTZWxmIiwicmVwZWF0IiwiX3RleHRfc2xpY2VfbWF0Y2giLCJfdGV4dF9zbGljZV9tYXRjaDEiLCJyZWxlYXNlUHJldmlvdXNNb2RpZmllciIsImVzY2FwZWREZXNjcmlwdG9yIiwiTnVtYmVyIiwic2xpY2UiLCJtYXRjaCIsInVuZGVmaW5lZCIsIl90ZXh0X3NsaWNlX21hdGNoXyIsInJlcGVhdE1vZGlmaWVyIiwicmVsZWFzZVNlbGZNb2RpZmllciIsImV4cGVjdGVkRW5kQnJhY2tldCIsImVuZEJyYWNrZXQiLCJFcnJvciIsImdldEVycm9yTWVzc2FnZSIsImZpbHRlciIsIkJvb2xlYW4iLCJqb2luIiwiTWF0aCIsIm1heCIsInN1YnN0ciIsImhhc1JlbGVhc2VTZWxmIiwiZXhwZWN0ZWQiLCJmb3VuZCIsImV4cG9ydHMiXSwic291cmNlcyI6WyJyZWFkTmV4dERlc2NyaXB0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnJhY2tldERpY3QgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKGJyYWNrZXREaWN0KSB7XG4gICAgYnJhY2tldERpY3RbXCJ7XCJdID0gXCJ9XCI7XG4gICAgYnJhY2tldERpY3RbXCJbXCJdID0gXCJdXCI7XG4gICAgcmV0dXJuIGJyYWNrZXREaWN0O1xufShicmFja2V0RGljdCB8fCB7fSk7XG4vKipcbiAqIFJlYWQgdGhlIG5leHQga2V5IGRlZmluaXRpb24gZnJvbSB1c2VyIGlucHV0XG4gKlxuICogRGVzY3JpYmUga2V5IHBlciBge2Rlc2NyaXB0b3J9YCBvciBgW2Rlc2NyaXB0b3JdYC5cbiAqIEV2ZXJ5dGhpbmcgZWxzZSB3aWxsIGJlIGludGVycHJldGVkIGFzIGEgc2luZ2xlIGNoYXJhY3RlciBhcyBkZXNjcmlwdG9yIC0gZS5nLiBgYWAuXG4gKiBCcmFja2V0cyBge2AgYW5kIGBbYCBjYW4gYmUgZXNjYXBlZCBieSBkb3VibGluZyAtIGUuZy4gYGZvb1tbYmFyYCB0cmFuc2xhdGVzIHRvIGBmb29bYmFyYC5cbiAqIEEgcHJldmlvdXNseSBwcmVzc2VkIGtleSBjYW4gYmUgcmVsZWFzZWQgcGVyIGB7L2Rlc2NyaXB0b3J9YC5cbiAqIEtlZXBpbmcgdGhlIGtleSBwcmVzc2VkIGNhbiBiZSB3cml0dGVuIGFzIGB7ZGVzY3JpcHRvcj59YC5cbiAqIFdoZW4ga2VlcGluZyB0aGUga2V5IHByZXNzZWQgeW91IGNhbiBjaG9vc2UgaG93IGxvbmcgdGhlIGtleSBpcyBwcmVzc2VkIGB7ZGVzY3JpcHRvcj4zfWAuXG4gKiBZb3UgY2FuIHRoZW4gcmVsZWFzZSB0aGUga2V5IHBlciBge2Rlc2NyaXB0b3I+My99YCBvciBrZWVwIGl0IHByZXNzZWQgYW5kIGNvbnRpbnVlIHdpdGggdGhlIG5leHQga2V5LlxuICovIGZ1bmN0aW9uIHJlYWROZXh0RGVzY3JpcHRvcih0ZXh0LCBjb250ZXh0KSB7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgY29uc3Qgc3RhcnRCcmFja2V0ID0gdGV4dFtwb3NdIGluIGJyYWNrZXREaWN0ID8gdGV4dFtwb3NdIDogJyc7XG4gICAgcG9zICs9IHN0YXJ0QnJhY2tldC5sZW5ndGg7XG4gICAgY29uc3QgaXNFc2NhcGVkQ2hhciA9IG5ldyBSZWdFeHAoYF5cXFxcJHtzdGFydEJyYWNrZXR9ezJ9YCkudGVzdCh0ZXh0KTtcbiAgICBjb25zdCB0eXBlID0gaXNFc2NhcGVkQ2hhciA/ICcnIDogc3RhcnRCcmFja2V0O1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIC4uLnR5cGUgPT09ICcnID8gcmVhZFByaW50YWJsZUNoYXIodGV4dCwgcG9zLCBjb250ZXh0KSA6IHJlYWRUYWcodGV4dCwgcG9zLCB0eXBlLCBjb250ZXh0KVxuICAgIH07XG59XG5mdW5jdGlvbiByZWFkUHJpbnRhYmxlQ2hhcih0ZXh0LCBwb3MsIGNvbnRleHQpIHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gdGV4dFtwb3NdO1xuICAgIGFzc2VydERlc2NyaXB0b3IoZGVzY3JpcHRvciwgdGV4dCwgcG9zLCBjb250ZXh0KTtcbiAgICBwb3MgKz0gZGVzY3JpcHRvci5sZW5ndGg7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uc3VtZWRMZW5ndGg6IHBvcyxcbiAgICAgICAgZGVzY3JpcHRvcixcbiAgICAgICAgcmVsZWFzZVByZXZpb3VzOiBmYWxzZSxcbiAgICAgICAgcmVsZWFzZVNlbGY6IHRydWUsXG4gICAgICAgIHJlcGVhdDogMVxuICAgIH07XG59XG5mdW5jdGlvbiByZWFkVGFnKHRleHQsIHBvcywgc3RhcnRCcmFja2V0LCBjb250ZXh0KSB7XG4gICAgdmFyIF90ZXh0X3NsaWNlX21hdGNoLCBfdGV4dF9zbGljZV9tYXRjaDE7XG4gICAgY29uc3QgcmVsZWFzZVByZXZpb3VzTW9kaWZpZXIgPSB0ZXh0W3Bvc10gPT09ICcvJyA/ICcvJyA6ICcnO1xuICAgIHBvcyArPSByZWxlYXNlUHJldmlvdXNNb2RpZmllci5sZW5ndGg7XG4gICAgY29uc3QgZXNjYXBlZERlc2NyaXB0b3IgPSBzdGFydEJyYWNrZXQgPT09ICd7JyAmJiB0ZXh0W3Bvc10gPT09ICdcXFxcJztcbiAgICBwb3MgKz0gTnVtYmVyKGVzY2FwZWREZXNjcmlwdG9yKTtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gZXNjYXBlZERlc2NyaXB0b3IgPyB0ZXh0W3Bvc10gOiAoX3RleHRfc2xpY2VfbWF0Y2ggPSB0ZXh0LnNsaWNlKHBvcykubWF0Y2goc3RhcnRCcmFja2V0ID09PSAneycgPyAvXlxcdyt8XltefT4vXS8gOiAvXlxcdysvKSkgPT09IG51bGwgfHwgX3RleHRfc2xpY2VfbWF0Y2ggPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IF90ZXh0X3NsaWNlX21hdGNoWzBdO1xuICAgIGFzc2VydERlc2NyaXB0b3IoZGVzY3JpcHRvciwgdGV4dCwgcG9zLCBjb250ZXh0KTtcbiAgICBwb3MgKz0gZGVzY3JpcHRvci5sZW5ndGg7XG4gICAgdmFyIF90ZXh0X3NsaWNlX21hdGNoXztcbiAgICBjb25zdCByZXBlYXRNb2RpZmllciA9IChfdGV4dF9zbGljZV9tYXRjaF8gPSAoX3RleHRfc2xpY2VfbWF0Y2gxID0gdGV4dC5zbGljZShwb3MpLm1hdGNoKC9ePlxcZCsvKSkgPT09IG51bGwgfHwgX3RleHRfc2xpY2VfbWF0Y2gxID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBfdGV4dF9zbGljZV9tYXRjaDFbMF0pICE9PSBudWxsICYmIF90ZXh0X3NsaWNlX21hdGNoXyAhPT0gdW5kZWZpbmVkID8gX3RleHRfc2xpY2VfbWF0Y2hfIDogJyc7XG4gICAgcG9zICs9IHJlcGVhdE1vZGlmaWVyLmxlbmd0aDtcbiAgICBjb25zdCByZWxlYXNlU2VsZk1vZGlmaWVyID0gdGV4dFtwb3NdID09PSAnLycgfHwgIXJlcGVhdE1vZGlmaWVyICYmIHRleHRbcG9zXSA9PT0gJz4nID8gdGV4dFtwb3NdIDogJyc7XG4gICAgcG9zICs9IHJlbGVhc2VTZWxmTW9kaWZpZXIubGVuZ3RoO1xuICAgIGNvbnN0IGV4cGVjdGVkRW5kQnJhY2tldCA9IGJyYWNrZXREaWN0W3N0YXJ0QnJhY2tldF07XG4gICAgY29uc3QgZW5kQnJhY2tldCA9IHRleHRbcG9zXSA9PT0gZXhwZWN0ZWRFbmRCcmFja2V0ID8gZXhwZWN0ZWRFbmRCcmFja2V0IDogJyc7XG4gICAgaWYgKCFlbmRCcmFja2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRFcnJvck1lc3NhZ2UoW1xuICAgICAgICAgICAgIXJlcGVhdE1vZGlmaWVyICYmICdyZXBlYXQgbW9kaWZpZXInLFxuICAgICAgICAgICAgIXJlbGVhc2VTZWxmTW9kaWZpZXIgJiYgJ3JlbGVhc2UgbW9kaWZpZXInLFxuICAgICAgICAgICAgYFwiJHtleHBlY3RlZEVuZEJyYWNrZXR9XCJgXG4gICAgICAgIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJyBvciAnKSwgdGV4dFtwb3NdLCB0ZXh0LCBjb250ZXh0KSk7XG4gICAgfVxuICAgIHBvcyArPSBlbmRCcmFja2V0Lmxlbmd0aDtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25zdW1lZExlbmd0aDogcG9zLFxuICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICByZWxlYXNlUHJldmlvdXM6ICEhcmVsZWFzZVByZXZpb3VzTW9kaWZpZXIsXG4gICAgICAgIHJlcGVhdDogcmVwZWF0TW9kaWZpZXIgPyBNYXRoLm1heChOdW1iZXIocmVwZWF0TW9kaWZpZXIuc3Vic3RyKDEpKSwgMSkgOiAxLFxuICAgICAgICByZWxlYXNlU2VsZjogaGFzUmVsZWFzZVNlbGYocmVsZWFzZVNlbGZNb2RpZmllciwgcmVwZWF0TW9kaWZpZXIpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFzc2VydERlc2NyaXB0b3IoZGVzY3JpcHRvciwgdGV4dCwgcG9zLCBjb250ZXh0KSB7XG4gICAgaWYgKCFkZXNjcmlwdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRFcnJvck1lc3NhZ2UoJ2tleSBkZXNjcmlwdG9yJywgdGV4dFtwb3NdLCB0ZXh0LCBjb250ZXh0KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzUmVsZWFzZVNlbGYocmVsZWFzZVNlbGZNb2RpZmllciwgcmVwZWF0TW9kaWZpZXIpIHtcbiAgICBpZiAocmVsZWFzZVNlbGZNb2RpZmllcikge1xuICAgICAgICByZXR1cm4gcmVsZWFzZVNlbGZNb2RpZmllciA9PT0gJy8nO1xuICAgIH1cbiAgICBpZiAocmVwZWF0TW9kaWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShleHBlY3RlZCwgZm91bmQsIHRleHQsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gYEV4cGVjdGVkICR7ZXhwZWN0ZWR9IGJ1dCBmb3VuZCBcIiR7Zm91bmQgIT09IG51bGwgJiYgZm91bmQgIT09IHVuZGVmaW5lZCA/IGZvdW5kIDogJyd9XCIgaW4gXCIke3RleHR9XCJcbiAgICBTZWUgJHtjb250ZXh0ID09PSAncG9pbnRlcicgPyBgaHR0cHM6Ly90ZXN0aW5nLWxpYnJhcnkuY29tL2RvY3MvdXNlci1ldmVudC9wb2ludGVyI3ByZXNzaW5nLWEtYnV0dG9uLW9yLXRvdWNoaW5nLXRoZS1zY3JlZW5gIDogYGh0dHBzOi8vdGVzdGluZy1saWJyYXJ5LmNvbS9kb2NzL3VzZXItZXZlbnQva2V5Ym9hcmRgfVxuICAgIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGhvdyB1c2VyRXZlbnQgcGFyc2VzIHlvdXIgaW5wdXQuYDtcbn1cblxuZXhwb3J0cy5yZWFkTmV4dERlc2NyaXB0b3IgPSByZWFkTmV4dERlc2NyaXB0b3I7XG4iXSwibWFwcGluZ3MiOiJBQUFBLFlBQVk7O0FBRVosSUFBSUEsV0FBVyxHQUFHLGFBQWMsVUFBU0EsV0FBVyxFQUFFO0VBQ2xEQSxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRztFQUN0QkEsV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUc7RUFDdEIsT0FBT0EsV0FBVztBQUN0QixDQUFDLENBQUNBLFdBQVcsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUksU0FBU0Msa0JBQWtCQSxDQUFDQyxJQUFJLEVBQUVDLE9BQU8sRUFBRTtFQUMzQyxJQUFJQyxHQUFHLEdBQUcsQ0FBQztFQUNYLE1BQU1DLFlBQVksR0FBR0gsSUFBSSxDQUFDRSxHQUFHLENBQUMsSUFBSUosV0FBVyxHQUFHRSxJQUFJLENBQUNFLEdBQUcsQ0FBQyxHQUFH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