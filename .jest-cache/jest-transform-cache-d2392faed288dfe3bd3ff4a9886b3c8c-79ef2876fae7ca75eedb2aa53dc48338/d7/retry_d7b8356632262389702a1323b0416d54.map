{"file":"C:\\Users\\sarah\\Repos\\CCH Axcess Intelligence Vibed\\src\\core\\utils\\retry.ts","mappings":"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","names":[],"sources":["C:\\Users\\sarah\\Repos\\CCH Axcess Intelligence Vibed\\src\\core\\utils\\retry.ts"],"sourcesContent":["import { logger } from '../logging/logger';\r\n\r\n/**\r\n * Retry configuration interface\r\n */\r\ninterface RetryConfig {\r\n  maxAttempts: number;\r\n  initialDelay: number;\r\n  maxDelay: number;\r\n  backoffMultiplier: number;\r\n  retryableErrors?: string[];\r\n  jitterRange?: number;\r\n}\r\n\r\n/**\r\n * Retry attempt context interface\r\n */\r\ninterface RetryContext {\r\n  attempt: number;\r\n  maxAttempts: number;\r\n  delay: number;\r\n  error?: Error;\r\n  context?: string;\r\n}\r\n\r\n/**\r\n * Retry result interface\r\n */\r\ninterface RetryResult<T> {\r\n  success: boolean;\r\n  data?: T;\r\n  error?: Error;\r\n  attempts: number;\r\n  totalTime: number;\r\n}\r\n\r\n/**\r\n * Retry with exponential backoff implementation\r\n */\r\nexport class RetryWithBackoff {\r\n  private config: RetryConfig = {\r\n    maxAttempts: 3,\r\n    initialDelay: 1000,\r\n    maxDelay: 10000,\r\n    backoffMultiplier: 2,\r\n    retryableErrors: ['NETWORK_ERROR', 'TIMEOUT', '503', '429', '502', '504'],\r\n    jitterRange: 1000\r\n  };\r\n\r\n  constructor(config?: Partial<RetryConfig>) {\r\n    this.config = { ...this.config, ...config };\r\n  }\r\n\r\n  /**\r\n   * Execute a function with retry logic\r\n   */\r\n  async execute<T>(\r\n    fn: () => Promise<T>,\r\n    context?: string\r\n  ): Promise<T> {\r\n    const startTime = Date.now();\r\n    let lastError: Error;\r\n    \r\n    for (let attempt = 1; attempt <= this.config.maxAttempts; attempt++) {\r\n      try {\r\n        logger.debug(`Retry attempt ${attempt}/${this.config.maxAttempts}`, { \r\n          context,\r\n          attempt,\r\n          maxAttempts: this.config.maxAttempts\r\n        });\r\n        \r\n        const result = await fn();\r\n        \r\n        // Log successful attempt\r\n        if (attempt > 1) {\r\n          logger.info(`Retry succeeded on attempt ${attempt}`, {\r\n            context,\r\n            attempts: attempt,\r\n            totalTime: Date.now() - startTime\r\n          });\r\n        }\r\n        \r\n        return result;\r\n      } catch (error) {\r\n        lastError = error as Error;\r\n        \r\n        if (!this.isRetryable(error) || attempt === this.config.maxAttempts) {\r\n          logger.error('Non-retryable error or max attempts reached', {\r\n            error: lastError.message,\r\n            errorCode: this.getErrorCode(error),\r\n            attempt,\r\n            maxAttempts: this.config.maxAttempts,\r\n            context,\r\n            totalTime: Date.now() - startTime\r\n          });\r\n          throw error;\r\n        }\r\n\r\n        const delay = this.calculateDelay(attempt);\r\n        logger.warn(`Retrying after ${delay}ms`, {\r\n          error: lastError.message,\r\n          errorCode: this.getErrorCode(error),\r\n          attempt,\r\n          nextAttempt: attempt + 1,\r\n          delay,\r\n          context\r\n        });\r\n        \r\n        await this.sleep(delay);\r\n      }\r\n    }\r\n    \r\n    throw lastError!;\r\n  }\r\n\r\n  /**\r\n   * Execute with detailed result information\r\n   */\r\n  async executeWithResult<T>(\r\n    fn: () => Promise<T>,\r\n    context?: string\r\n  ): Promise<RetryResult<T>> {\r\n    const startTime = Date.now();\r\n    let lastError: Error;\r\n    \r\n    for (let attempt = 1; attempt <= this.config.maxAttempts; attempt++) {\r\n      try {\r\n        const result = await fn();\r\n        \r\n        return {\r\n          success: true,\r\n          data: result,\r\n          attempts: attempt,\r\n          totalTime: Date.now() - startTime\r\n        };\r\n      } catch (error) {\r\n        lastError = error as Error;\r\n        \r\n        if (!this.isRetryable(error) || attempt === this.config.maxAttempts) {\r\n          return {\r\n            success: false,\r\n            error: lastError,\r\n            attempts: attempt,\r\n            totalTime: Date.now() - startTime\r\n          };\r\n        }\r\n\r\n        const delay = this.calculateDelay(attempt);\r\n        await this.sleep(delay);\r\n      }\r\n    }\r\n    \r\n    return {\r\n      success: false,\r\n      error: lastError!,\r\n      attempts: this.config.maxAttempts,\r\n      totalTime: Date.now() - startTime\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if an error is retryable\r\n   */\r\n  private isRetryable(error: unknown): boolean {\r\n    const errorMessage = this.getErrorMessage(error);\r\n    const errorCode = this.getErrorCode(error);\r\n    \r\n    // Check if error message contains retryable patterns\r\n    const isRetryableMessage = this.config.retryableErrors!.some(\r\n      retryableError => errorMessage.includes(retryableError)\r\n    );\r\n    \r\n    // Check if error code is retryable\r\n    const isRetryableCode = this.config.retryableErrors!.some(\r\n      retryableError => errorCode.includes(retryableError)\r\n    );\r\n    \r\n    return isRetryableMessage || isRetryableCode;\r\n  }\r\n\r\n  /**\r\n   * Calculate delay with exponential backoff and jitter\r\n   */\r\n  private calculateDelay(attempt: number): number {\r\n    const baseDelay = Math.min(\r\n      this.config.initialDelay * Math.pow(this.config.backoffMultiplier, attempt - 1),\r\n      this.config.maxDelay\r\n    );\r\n    \r\n    // Add jitter to prevent thundering herd\r\n    const jitter = Math.random() * (this.config.jitterRange || 1000);\r\n    \r\n    return Math.floor(baseDelay + jitter);\r\n  }\r\n\r\n  /**\r\n   * Sleep for specified milliseconds\r\n   */\r\n  private sleep(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n  }\r\n\r\n  /**\r\n   * Extract error message from various error types\r\n   */\r\n  private getErrorMessage(error: unknown): string {\r\n    if (error instanceof Error) {\r\n      return error.message;\r\n    }\r\n    if (typeof error === 'string') {\r\n      return error;\r\n    }\r\n    if (error && typeof error === 'object' && 'message' in error) {\r\n      return String(error.message);\r\n    }\r\n    return 'Unknown error';\r\n  }\r\n\r\n  /**\r\n   * Extract error code from various error types\r\n   */\r\n  private getErrorCode(error: unknown): string {\r\n    if (error && typeof error === 'object') {\r\n      if ('code' in error) {\r\n        return String(error.code);\r\n      }\r\n      if ('status' in error) {\r\n        return String(error.status);\r\n      }\r\n      if ('statusCode' in error) {\r\n        return String(error.statusCode);\r\n      }\r\n    }\r\n    return '';\r\n  }\r\n\r\n  /**\r\n   * Get current retry configuration\r\n   */\r\n  getConfig(): RetryConfig {\r\n    return { ...this.config };\r\n  }\r\n\r\n  /**\r\n   * Update retry configuration\r\n   */\r\n  updateConfig(config: Partial<RetryConfig>): void {\r\n    this.config = { ...this.config, ...config };\r\n  }\r\n}\r\n\r\n/**\r\n * Default retry instance for common use cases\r\n */\r\nexport const defaultRetry = new RetryWithBackoff();\r\n\r\n/**\r\n * Quick retry utility for simple operations\r\n */\r\nexport const quickRetry = new RetryWithBackoff({\r\n  maxAttempts: 2,\r\n  initialDelay: 500,\r\n  maxDelay: 2000\r\n});\r\n\r\n/**\r\n * Aggressive retry utility for critical operations\r\n */\r\nexport const aggressiveRetry = new RetryWithBackoff({\r\n  maxAttempts: 5,\r\n  initialDelay: 2000,\r\n  maxDelay: 30000,\r\n  backoffMultiplier: 1.5\r\n});\r\n"],"version":3}