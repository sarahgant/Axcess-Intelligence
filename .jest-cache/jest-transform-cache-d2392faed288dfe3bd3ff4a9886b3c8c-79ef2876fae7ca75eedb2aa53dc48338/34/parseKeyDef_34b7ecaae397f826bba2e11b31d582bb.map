{"version":3,"names":["require","readNextDescriptor","parseKeyDef","keyboardMap","text","defs","type","descriptor","consumedLength","releasePrevious","releaseSelf","repeat","_keyboardMap_find","keyDef","find","def","_def_code","code","undefined","toLowerCase","_def_key","key","push","slice","exports"],"sources":["parseKeyDef.js"],"sourcesContent":["'use strict';\n\nrequire('../utils/dataTransfer/Clipboard.js');\nvar readNextDescriptor = require('../utils/keyDef/readNextDescriptor.js');\n\n/**\n * Parse key definitions per `keyboardMap`\n *\n * Keys can be referenced by `{key}` or `{special}` as well as physical locations per `[code]`.\n * Everything else will be interpreted as a typed character - e.g. `a`.\n * Brackets `{` and `[` can be escaped by doubling - e.g. `foo[[bar` translates to `foo[bar`.\n * Keeping the key pressed can be written as `{key>}`.\n * When keeping the key pressed you can choose how long (how many keydown and keypress) the key is pressed `{key>3}`.\n * You can then release the key per `{key>3/}` or keep it pressed and continue with the next key.\n */ function parseKeyDef(keyboardMap, text) {\n    const defs = [];\n    do {\n        const { type, descriptor, consumedLength, releasePrevious, releaseSelf = true, repeat } = readNextDescriptor.readNextDescriptor(text, 'keyboard');\n        var _keyboardMap_find;\n        const keyDef = (_keyboardMap_find = keyboardMap.find((def)=>{\n            if (type === '[') {\n                var _def_code;\n                return ((_def_code = def.code) === null || _def_code === undefined ? undefined : _def_code.toLowerCase()) === descriptor.toLowerCase();\n            } else if (type === '{') {\n                var _def_key;\n                return ((_def_key = def.key) === null || _def_key === undefined ? undefined : _def_key.toLowerCase()) === descriptor.toLowerCase();\n            }\n            return def.key === descriptor;\n        })) !== null && _keyboardMap_find !== undefined ? _keyboardMap_find : {\n            key: 'Unknown',\n            code: 'Unknown',\n            [type === '[' ? 'code' : 'key']: descriptor\n        };\n        defs.push({\n            keyDef,\n            releasePrevious,\n            releaseSelf,\n            repeat\n        });\n        text = text.slice(consumedLength);\n    }while (text)\n    return defs;\n}\n\nexports.parseKeyDef = parseKeyDef;\n"],"mappings":"AAAA,YAAY;;AAEZA,OAAO,CAAC,oCAAoC,CAAC;AAC7C,IAAIC,kBAAkB,GAAGD,OAAO,CAAC,uCAAuC,CAAC;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAI,SAASE,WAAWA,CAACC,WAAW,EAAEC,IAAI,EAAE;EACxC,MAAMC,IAAI,GAAG,EAAE;EACf,GAAG;IACC,MAAM;MAAEC,IAAI;MAAEC,UAAU;MAAEC,cAAc;MAAEC,eAAe;MAAEC,WAAW,GAAG,IAAI;MAAEC;IAAO,CAAC,GAAGV,kBAAkB,CAACA,kBAAkB,CAACG,IAAI,EAAE,UAAU,CAAC;IACjJ,IAAIQ,iBAAiB;IACrB,MAAMC,MAAM,GAAG,CAACD,iBAAiB,GAAGT,WAAW,CAACW,IAAI,CAAEC,GAAG,IAAG;MACxD,IAAIT,IAAI,KAAK,GAAG,EAAE;QACd,IAAIU,SAAS;QACb,OAAO,CAAC,CAACA,SAAS,GAAGD,GAAG,CAACE,IAAI,MAAM,IAAI,IAAID,SAAS,KAAKE,SAAS,GAAGA,SAAS,GAAGF,SAAS,CAACG,WAAW,CAAC,CAAC,MAAMZ,UAAU,CAACY,WAAW,CAAC,CAAC;MAC1I,CAAC,MAAM,IAAIb,IAAI,KAAK,GAAG,EAAE;QACrB,IAAIc,QAAQ;QACZ,OAAO,CAAC,CAACA,QAAQ,GAAGL,GAAG,CAACM,GAAG,MAAM,IAAI,IAAID,QAAQ,KAAKF,SAAS,GAAGA,SAAS,GAAGE,QAAQ,CAACD,WAAW,CAAC,CAAC,MAAMZ,UAAU,CAACY,WAAW,CAAC,CAAC;MACtI;MACA,OAAOJ,GAAG,CAACM,GAAG,KAAKd,UAAU;IACjC,CAAC,CAAC,MAAM,IAAI,IAAIK,iBAAiB,KAAKM,SAAS,GAAGN,iBAAiB,GAAG;MAClES,GAAG,EAAE,SAAS;MACdJ,IAAI,EAAE,SAAS;MACf,CAACX,IAAI,KAAK,GAAG,GAAG,MAAM,GAAG,KAAK,GAAGC;IACrC,CAAC;IACDF,IAAI,CAACiB,IAAI,CAAC;MACNT,MAAM;MACNJ,eAAe;MACfC,WAAW;MACXC;IACJ,CAAC,CAAC;IACFP,IAAI,GAAGA,IAAI,CAACmB,KAAK,CAACf,cAAc,CAAC;EACrC,CAAC,QAAOJ,IAAI;EACZ,OAAOC,IAAI;AACf;AAEAmB,OAAO,CAACtB,WAAW,GAAGA,WAAW","ignoreList":[]}