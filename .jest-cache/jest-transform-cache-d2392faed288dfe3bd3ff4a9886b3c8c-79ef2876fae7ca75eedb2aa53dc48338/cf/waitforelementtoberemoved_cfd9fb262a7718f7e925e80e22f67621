b65c781ccaca9c233c97ba37077585ef
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.waitForElementToBeRemoved = waitForElementToBeRemoved;
var _waitFor = require("./wait-for");
const isRemoved = result => !result || Array.isArray(result) && !result.length;

// Check if the element is not present.
// As the name implies, waitForElementToBeRemoved should check `present` --> `removed`
function initialCheck(elements) {
  if (isRemoved(elements)) {
    throw new Error('The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.');
  }
}
async function waitForElementToBeRemoved(callback, options) {
  // created here so we get a nice stacktrace
  const timeoutError = new Error('Timed out in waitForElementToBeRemoved.');
  if (typeof callback !== 'function') {
    initialCheck(callback);
    const elements = Array.isArray(callback) ? callback : [callback];
    const getRemainingElements = elements.map(element => {
      let parent = element.parentElement;
      if (parent === null) return () => null;
      while (parent.parentElement) parent = parent.parentElement;
      return () => parent.contains(element) ? element : null;
    });
    callback = () => getRemainingElements.map(c => c()).filter(Boolean);
  }
  initialCheck(callback());
  return (0, _waitFor.waitFor)(() => {
    let result;
    try {
      result = callback();
    } catch (error) {
      if (error.name === 'TestingLibraryElementError') {
        return undefined;
      }
      throw error;
    }
    if (!isRemoved(result)) {
      throw timeoutError;
    }
    return undefined;
  }, options);
}

/*
eslint
  require-await: "off"
*/
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIndhaXRGb3JFbGVtZW50VG9CZVJlbW92ZWQiLCJfd2FpdEZvciIsInJlcXVpcmUiLCJpc1JlbW92ZWQiLCJyZXN1bHQiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJpbml0aWFsQ2hlY2siLCJlbGVtZW50cyIsIkVycm9yIiwiY2FsbGJhY2siLCJvcHRpb25zIiwidGltZW91dEVycm9yIiwiZ2V0UmVtYWluaW5nRWxlbWVudHMiLCJtYXAiLCJlbGVtZW50IiwicGFyZW50IiwicGFyZW50RWxlbWVudCIsImNvbnRhaW5zIiwiYyIsImZpbHRlciIsIkJvb2xlYW4iLCJ3YWl0Rm9yIiwiZXJyb3IiLCJuYW1lIiwidW5kZWZpbmVkIl0sInNvdXJjZXMiOlsid2FpdC1mb3ItZWxlbWVudC10by1iZS1yZW1vdmVkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy53YWl0Rm9yRWxlbWVudFRvQmVSZW1vdmVkID0gd2FpdEZvckVsZW1lbnRUb0JlUmVtb3ZlZDtcbnZhciBfd2FpdEZvciA9IHJlcXVpcmUoXCIuL3dhaXQtZm9yXCIpO1xuY29uc3QgaXNSZW1vdmVkID0gcmVzdWx0ID0+ICFyZXN1bHQgfHwgQXJyYXkuaXNBcnJheShyZXN1bHQpICYmICFyZXN1bHQubGVuZ3RoO1xuXG4vLyBDaGVjayBpZiB0aGUgZWxlbWVudCBpcyBub3QgcHJlc2VudC5cbi8vIEFzIHRoZSBuYW1lIGltcGxpZXMsIHdhaXRGb3JFbGVtZW50VG9CZVJlbW92ZWQgc2hvdWxkIGNoZWNrIGBwcmVzZW50YCAtLT4gYHJlbW92ZWRgXG5mdW5jdGlvbiBpbml0aWFsQ2hlY2soZWxlbWVudHMpIHtcbiAgaWYgKGlzUmVtb3ZlZChlbGVtZW50cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBlbGVtZW50KHMpIGdpdmVuIHRvIHdhaXRGb3JFbGVtZW50VG9CZVJlbW92ZWQgYXJlIGFscmVhZHkgcmVtb3ZlZC4gd2FpdEZvckVsZW1lbnRUb0JlUmVtb3ZlZCByZXF1aXJlcyB0aGF0IHRoZSBlbGVtZW50KHMpIGV4aXN0KHMpIGJlZm9yZSB3YWl0aW5nIGZvciByZW1vdmFsLicpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiB3YWl0Rm9yRWxlbWVudFRvQmVSZW1vdmVkKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIC8vIGNyZWF0ZWQgaGVyZSBzbyB3ZSBnZXQgYSBuaWNlIHN0YWNrdHJhY2VcbiAgY29uc3QgdGltZW91dEVycm9yID0gbmV3IEVycm9yKCdUaW1lZCBvdXQgaW4gd2FpdEZvckVsZW1lbnRUb0JlUmVtb3ZlZC4nKTtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGluaXRpYWxDaGVjayhjYWxsYmFjayk7XG4gICAgY29uc3QgZWxlbWVudHMgPSBBcnJheS5pc0FycmF5KGNhbGxiYWNrKSA/IGNhbGxiYWNrIDogW2NhbGxiYWNrXTtcbiAgICBjb25zdCBnZXRSZW1haW5pbmdFbGVtZW50cyA9IGVsZW1lbnRzLm1hcChlbGVtZW50ID0+IHtcbiAgICAgIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICBpZiAocGFyZW50ID09PSBudWxsKSByZXR1cm4gKCkgPT4gbnVsbDtcbiAgICAgIHdoaWxlIChwYXJlbnQucGFyZW50RWxlbWVudCkgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICByZXR1cm4gKCkgPT4gcGFyZW50LmNvbnRhaW5zKGVsZW1lbnQpID8gZWxlbWVudCA6IG51bGw7XG4gICAgfSk7XG4gICAgY2FsbGJhY2sgPSAoKSA9PiBnZXRSZW1haW5pbmdFbGVtZW50cy5tYXAoYyA9PiBjKCkpLmZpbHRlcihCb29sZWFuKTtcbiAgfVxuICBpbml0aWFsQ2hlY2soY2FsbGJhY2soKSk7XG4gIHJldHVybiAoMCwgX3dhaXRGb3Iud2FpdEZvcikoKCkgPT4ge1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnVGVzdGluZ0xpYnJhcnlFbGVtZW50RXJyb3InKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKCFpc1JlbW92ZWQocmVzdWx0KSkge1xuICAgICAgdGhyb3cgdGltZW91dEVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LCBvcHRpb25zKTtcbn1cblxuLypcbmVzbGludFxuICByZXF1aXJlLWF3YWl0OiBcIm9mZlwiXG4qLyJdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWTs7QUFFWkEsTUFBTSxDQUFDQyxjQUFjLENBQUNDLE9BQU8sRUFBRSxZQUFZLEVBQUU7RUFDM0NDLEtBQUssRUFBRTtBQUNULENBQUMsQ0FBQztBQUNGRCxPQUFPLENBQUNFLHlCQUF5QixHQUFHQSx5QkFBeUI7QUFDN0QsSUFBSUMsUUFBUSxHQUFHQyxPQUFPLENBQUMsWUFBWSxDQUFDO0FBQ3BDLE1BQU1DLFNBQVMsR0FBR0MsTUFBTSxJQUFJLENBQUNBLE1BQU0sSUFBSUMsS0FBSyxDQUFDQyxPQUFPLENBQUNGLE1BQU0sQ0FBQyxJQUFJLENBQUNBLE1BQU0sQ0FBQ0csTUFBTTs7QUFFOUU7QUFDQTtBQUNBLFNBQVNDLFlBQVlBLENBQUNDLFFBQVEsRUFBRTtFQUM5QixJQUFJTixTQUFTLENBQUNNLFFBQVEsQ0FBQyxFQUFFO0lBQ3ZCLE1BQU0sSUFBSUMsS0FBSyxDQUFDLG9LQUFvSyxDQUFDO0VBQ3ZMO0FBQ0Y7QUFDQSxlQUFlVix5QkFBeUJBLENBQUNXLFFBQVEsRUFBRUMsT0FBTyxFQUFFO0VBQzFEO0VBQ0EsTUFBTUMsWUFBWSxHQUFHLElBQUlILEtBQUssQ0FBQyx5Q0FBeUMsQ0FBQztFQUN6RSxJQUFJLE9BQU9DLFFBQVEsS0FBSyxVQUFVLEVBQUU7SUFDbENILFlBQVksQ0FBQ0csUUFBUSxDQUFDO0lBQ3RCLE1BQU1GLFFBQVEsR0FBR0osS0FBSyxDQUFDQyxPQUFPLENBQUNLLFFBQVEsQ0FBQyxHQUFHQSxRQUFRLEdBQUcsQ0FBQ0EsUUFBUSxDQUFDO0lBQ2hFLE1BQU1HLG9CQUFvQixHQUFHTCxRQUFRLENBQUNNLEdBQUcsQ0FBQ0MsT0FBTyxJQUFJO01BQ25ELElBQUlDLE1BQU0sR0FBR0QsT0FBTyxDQUFDRSxhQUFhO01BQ2xDLElBQUlELE1BQU0sS0FBSyxJQUFJLEVBQUUsT0FBTyxNQUFNLElBQUk7TUFDdEMsT0FBT0EsTUFBTSxDQUFDQyxhQUFhLEVBQUVELE1BQU0sR0FBR0EsTUFBTSxDQUFDQyxhQUFhO01BQzFELE9BQU8sTUFBTUQsTUFBTSxDQUFDRSxRQUFRLENBQUNILE9BQU8sQ0FBQyxHQUFHQSxPQUFPLEdBQUcsSUFBSTtJQUN4RCxDQUFDLENBQUM7SUFDRkwsUUFBUSxHQUFHQSxDQUFBLEtBQU1HLG9CQUFvQixDQUFDQyxHQUFHLENBQUNLLENBQUMsSUFBSUEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDQyxNQUFNLENBQUNDLE9BQU8sQ0FBQztFQUNyRTtFQUNBZCxZQUFZLENBQUNHLFFBQVEsQ0FBQyxDQUFDLENBQUM7RUFDeEIsT0FBTyxDQUFDLENBQUMsRUFBRVYsUUFBUSxDQUFDc0IsT0FBTyxFQUFFLE1BQU07SUFDakMsSUFBSW5CLE1BQU07SUFDVixJQUFJO01BQ0ZBLE1BQU0sR0FBR08sUUFBUSxDQUFDLENBQUM7SUFDckIsQ0FBQyxDQUFDLE9BQU9hLEtBQUssRUFBRTtNQUNkLElBQUlBLEtBQUssQ0FBQ0MsSUFBSSxLQUFLLDRCQUE0QixFQUFFO1FBQy9DLE9BQU9DLFNBQVM7TUFDbEI7TUFDQSxNQUFNRixLQUFLO0lBQ2I7SUFDQSxJQUFJLENBQUNyQixTQUFTLENBQUNDLE1BQU0sQ0FBQyxFQUFFO01BQ3RCLE1BQU1TLFlBQVk7SUFDcEI7SUFDQSxPQUFPYSxTQUFTO0VBQ2xCLENBQUMsRUFBRWQsT0FBTyxDQUFDO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJpZ25vcmVMaXN0IjpbXX0=